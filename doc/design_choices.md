# Design Choices

This section describes the guiding design choices that are attempted to be
implemented in the NUISANCE v3 rewrite. Any perceived failure to adhere to these design choices should be regarded as a bug and submitted to the developers.

## Modularity of components

The various moving parts that go into a NUISANCE analysis should be as independent as possible (and no more). For example, as in previous versions, 'input handlers' are implementations of an `InputHandler` ABC, they are responsible for converting a specific event format into the NUISANCE event format. This event format should be generator agnostic as far as possible, however, for the generator-based-event reweighting to perform efficiently, the original generator event must be associated to the NUISANCE event. Instead of having some per-generator event manager, or reweight engines being allowed specific access to known InputHandler subclasses, it was decided that a pointer to the generator event would be carried around by the NUISANCE event base-class. This design choice has been kept.

In NUISANCE v3, the design of the 'sample', the basic implementation unit of a comparison, has been further modularized. The previous Measurement{Base,1D,2D} base classes have been surplanted by the ISample and IDataComparison interfaces. IDataComparison being a subclass of ISample. These specify the interface that any NUISANCE sample must implement. The implementation of any subclass is left up to the user, however, a helper base class that should be used for almost all simple data comparisons can be found in SimpleDataComparison. It attempts to provide a fully functional base class, for data comparisons that previously subclassed from Measurement1D or 2D, that needs minimal specializing for specific data samples---most importantly the signal definition, the kinematic projection, and optional-but-encouraged data set metadata. As the interface suggests, the responsibility of looping over events and determining event variations is now fully that of the ISample, rather than a finely tuned collaboration between the sample and some calling method. However, subclasses of SimpleDataComparison can still be fully implemented by providing only per-event methods as the base class handles the event looping.

Related to this, it may be useful to extend the 'reweight' concept, which was assumed to be the only form of event response in previous versions to a more general event 'variation'. However, since the majority of variations will still be weight-based, and as weight-based variations can often be calculated and applied fully with just the `nuis::event::MinimalEvent` format, the InputHandler will expose convenience methods that allow the current event weight to be without direct interrogation of any IWeightProvider instances. However, because general event variations can be arbitrarily complex and can require signal definitions to be rechecked (requiring a `nuis::event::FullEvent`), no such convenience method exists and samples looking to make use of such variations must explicitly call the VariationManager.

## Extensibility without recompilation

In previous versions of NUISANCE, the addition of new studies by non-experts was somewhat involved. Even though well-documented in multiple tutorials the addition of new studies required multiple source code changes, for opaque reasons outside of the study implementation itself. It also required recompilation of the entire set of NUISANCE binaries, this makes sharing a NUISANCE release on a cluster problematic and limits the entry barrier for non-expert users. V3 of NUISANCE is built from the ground up to allow for use and extensibility by non-experts, this is primarily facilitated by the `Instantiate` template method that implements a plugin factory, somewhat inspired by the `art::make_tool` utility from the ART framework. While the architecture of c++ means that plugins compiled with different toolsets than the main NUISANCE binaries are unlikely to work (and thus checked and disallowed before attempting any c++ object instantiation), multiple users working on a cluster should now be able to have local analysis implementations that are dynamically instantiated at runtime and require no recompilation of a central NUISANCE install.

## Flexibility of configuration

Originally NUISANCE used an inflexible DSL for configuration, in v2, a more-flexible XML-based configuration file was used. The change increased the scope of specific extensions to the core configuration, but the configuration API was clunky. In v3, NUISANCE uses an implementation of the FHiCL-c++ language
bindings to provide both configuration parsing and validation, as well as programatic access to the runtime configuration. FHiCL is particularly adept at providing a naturally hierarchial configuration, whereby global defaults can be
specified but overridden at runtime by user-supplied configuration files without special handling of the in-memory global configuration document. The FHiCL language bindings also specify how to retrieve configuration elements with specified types, reducing the need for comprehensive runtime checks for missing or incomplete configuration.

## Exceptional circumstances

Previously, when NUISANCE encountered exceptional circumstances an exception was thrown. This exception was usually unqualified and sometimes preceeded by an error message. This made debugging and reporting of runtime errors fiddly for non-experts. In v3, all exceptions should be sensibly named, derived from `nuis::nuis_except` and be supplied with a verbose message diagnosing the problem encountered.

## Documentation

The inline documentation of the code in previous versions of NUISANCE has been acceptable. The barrier to entry for new users was significantly lowered by external tutorials and documents. For v3, the hope is that the interface documentation can be fully comprehensive, and a specific set of instructions for common and less-common tasks can be distributed with the code. In addition to this, applications and scripts that verbosely aid users in standard NUISANCE workflows should be provided, and all usage prompts should be kept informative and fully up-to-date.
